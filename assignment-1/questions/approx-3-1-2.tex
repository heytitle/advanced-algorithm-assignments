\section*{AIII-1-ii)}
\label{approx-3-1-ii}

Let's denote a total sum of the running time of all jobs as $ T $ and running time of the longest job as $ t_{max} $.
From the description of the problem we can deduce a lowerbound.
\begin{itemize}
	\item $ LB = \frac{1}{2} T $ when all jobs can be evenly splitted into two machines.
	\item $ LB = t_{max} $ when the longest running job is longer than all other jobs together, we schedule it on one
		machine leaving all the other jobs on the second.
\end{itemize}

To obtain PTAS, first we classify the jobs in the schedule according to problem description
We split them up into two sizes :
\begin{align*}
    \text{Job is } \begin{cases}
        \text{Large} \text{ if } t_j \ge \epsilon T \\
        \text{Small} \text{ if } t_j < \epsilon T \\
    \end{cases}
\end{align*}

Furthermore we can solve the problem for the large jobs by taking all of them and finding a solution using a brute-force method
(first generate all possible schedules and then find the makespan for all of them, choose the one with smallest).
This leaves us with small jobs to schedule. We can do this using a greedy approach. Simply we take all the small jobs and for each
of them we assign it to the machine with the lowest load.

\begin{algorithm}[H]
  \caption{Load Balancing PTAS}
  \label{alg:load_balancing_ptas}
  \begin{algorithmic}
    \Require Set of j jobs with running time $t_j$
    \Ensure Scheduling scenario with a lowest maximum running time of the two machine 
    \renewcommand{\algorithmicrequire}{\textbf{Input:}}
    \renewcommand{\algorithmicensure}{\textbf{Output:}}
    \algnewcommand\algorithmicoperation{\textbf{Operation:}}
    \algnewcommand\Operation{\item[\algorithmicoperation]}
    \Operation
    \State Split the input into set of small jobs $ S $ and a set of large jobs $ L $  based on the definition.
    \State Generate a list of all possible scheduling scenarios for large jobs $ LargeSchedules $.
    \State Establish $ MinMakeSpan := \infty $ and $ BestSchedule:= null $
    \ForAll {Scenario $Scen$ in $ LargeSchedules $}
    \State Calculate minimal makespan of the two machines $ l_{min} $
    \If {$ l_{min} \le MinMakeSpan $}
    \State $ MinMakeSpan := s_{min} $ and $ BestSchedule := Scen $
    \EndIf
    \EndFor
    \ForAll {Small Job $s$ in $S$}
    \State Schedule $ s $ to the machine with the lower current load
    \EndFor\\
    \Return BestSchedule
  \end{algorithmic}
\end{algorithm}

\textbf{Proof}

To prove that our algorithm is indeed a PTAS we need to show the following :
$$ ALG \le (1 + \epsilon ) OPT $$ 

Since part one of the algorithm will always return an optimal solution (it checks all 
the possible solutions) we can skip it and concentrate instead on the greed solution
to scheduling the small jobs.

If we denote 
\begin{itemize}
	\item $ M $ as a makespan generated by our solution
	\item $ T $ total running time of all jobs.
	\item $ T' $ as the running time in our solution before assigning the last job
	\item $ t_{last} $ as the running time of the last scheduled job
\end{itemize}
We come up with :
$$ M = T' + t_{last} \le ( T - t_{last} )/2 + t_{last} \le T/2 + \epsilon * (T/2) \le T + \epsilon * T = (1 + \epsilon ) OPT $$

It has to be noted that in a case where $ \epsilon $ is chosen so there are no small jobs in the schedule we fallback to the brute-force solution for Large Jobs, therefore the solution is always OPT for that case.

\textbf{Running Time}
Since there can be only at most $ 2^{\frac{1}{\epsilon}-1} $ possible large jobs, then the brute-force part of the algorithm will have a running time of $ O(2^{\frac{1}{\epsilon}-1}) $. The greedy scheduling of the large jobs is faster with linear time $ O(n) $ for $ n $ jobs. Leaving a total running time - $ O(2^{\frac{1}{\epsilon}-1} + n) $.

