\section*{AIII-1-ii)}
\label{approx-3-1-ii}

Let's denote a total sum of the running time of all jobs as $ T $ and running time of the longest job as $ t_{max} $.
So $OPT \geq max(\frac{T}{2}, t_{max})$, then $LB = max(\frac{T}{2}, t_{max})$.

To obtain PTAS, first we classify the jobs in the schedule according to problem description
We split them up into two sizes :
\begin{align*}
    \text{Job is } \begin{cases}
        \text{Large} \text{ if } t_j \ge \epsilon T \\
        \text{Small} \text{ if } t_j < \epsilon T \\
    \end{cases}
\end{align*}

Furthermore we can solve the problem for the large jobs by taking all of them and finding a solution using a brute-force method
(first generate all possible schedules and then find the makespan for all of them, choose the one with smallest).
This leaves us with small jobs to schedule. We can do this using a greedy approach. Simply we take all the small jobs and for each
of them we assign it to the machine with the lowest load.

\begin{algorithm}[H]
  \caption{Load Balancing PTAS}
  \label{alg:load_balancing_ptas}
  \begin{algorithmic}
    \Require Set of j jobs with running time $t_j$
    \Ensure Scheduling scenario with a lowest maximum running time of the two machine 
    \renewcommand{\algorithmicrequire}{\textbf{Input:}}
    \renewcommand{\algorithmicensure}{\textbf{Output:}}
    \algnewcommand\algorithmicoperation{\textbf{Operation:}}
    \algnewcommand\Operation{\item[\algorithmicoperation]}
    \Operation
    \State Split the input into set of small jobs $ S $ and a set of large jobs $ L $  based on the definition.
    \State Generate a list of all possible scheduling scenarios for large jobs $ LargeSchedules $.
    \State Establish $ MinMakeSpan := \infty $ and $ BestSchedule:= null $
    \ForAll {Scenario $Scen$ in $ LargeSchedules $}
    \State Calculate minimal makespan of the two machines $ l_{min} $
    \If {$ l_{min} \le MinMakeSpan $}
    \State $ MinMakeSpan := s_{min} $ and $ BestSchedule := Scen $
    \EndIf
    \EndFor
    \ForAll {Small Job $s$ in $S$}
    \State Schedule $ s $ to the machine with the lower current load
    \EndFor\\
    \Return BestSchedule
  \end{algorithmic}
\end{algorithm}

\textbf{Proof}

To prove that our algorithm is indeed a PTAS we need to show that it runs in polynomial time, and the following statement is true :
$$ ALG \le (1 + \epsilon ) OPT $$ 

Since part one of the algorithm will always return an optimal solution (it checks all 
the possible solutions) we can skip it and concentrate instead on the greedy solution
to scheduling the small jobs.

If we denote 
\begin{itemize}
	\item $ M $ as a makespan generated by our solution
	\item $ T $ total running time of all jobs.
	\item $ T' $ as the running time in our solution before assigning the last job
	\item $ t_{last} $ as the running time of the last scheduled job
\end{itemize}
We come up with :
$$ M = T' + t_{last} \le \frac{T - t_{last}}{2} + t_{last} \le \frac{T}{2} + \frac{\epsilon T}{2} \le (1 + \epsilon)\frac{T}{2} \le (1 + \epsilon )LB \le (1 + \epsilon)OPT$$

When $\epsilon$ is small enough, there are no small jobs in the schedule, we fallback to the brute-force solution for Large Jobs, therefore the solution is always OPT for that case. Then the approximation ratio still holds as $(1 + \epsilon)$ where $\epsilon$ is very small ($\epsilon \to 0$).

\textbf{Running Time}
Since there can be only at most $ 2^{\frac{1}{\epsilon}-1} $ possible large jobs, then the brute-force part of the algorithm will have a running time of $ O(2^{\frac{1}{\epsilon}-1}) $. The greedy scheduling of the large jobs is faster with linear time $ O(n) $ for $ n $ jobs. Leaving a total running time - $ O(2^{\frac{1}{\epsilon}-1} + n) $, which is polynomial in term of $n$. So this algorithm satisfies the condition of a PTAS.

